# docker-compose.yml
# Production-ready Docker Compose configuration with comprehensive security hardening
# Based on DOCKER-REFACTORING-PLAN.md Phase 1 implementation
#
# =============================================================================
# ENVIRONMENT FILE SETUP (REQUIRED!)
# =============================================================================
# Docker Compose reads .env by default for variable substitution.
# Setup options:
#
#   Option 1 (Recommended): Create symlink
#     ln -s .env.docker .env
#
#   Option 2: Copy template
#     cp .env.docker.template .env.docker && ln -s .env.docker .env
#
#   Option 3: Manual per-command
#     docker-compose --env-file .env.docker <command>
#
# IMPORTANT: The environment file MUST exist with valid paths, otherwise
# volume mounts will fail silently with empty paths!
# =============================================================================
#
# Usage:
#   Development: docker-compose -f docker-compose.yml -f docker-compose.dev.yml up
#   Production:  docker-compose up
#
# Security Features:
# - Non-root user execution (UID 10001 for API, UID 101 for frontend)
# - Resource limits (CPU, memory)
# - Read-only root filesystems with tmpfs for writable directories
# - Capability dropping (CAP_DROP: ALL)
# - Security options (no-new-privileges, seccomp)
# - Enhanced health checks
# - Structured logging with rotation
# - Network isolation

services:
  phentrieve_api:
    image: ghcr.io/berntpopp/phentrieve/api:latest
    build:
      context: .
      dockerfile: api/Dockerfile
      args:
        BUILDKIT_INLINE_CACHE: 1
        # =============================================================================
        # DATA PREPARATION MODE (three options - see api/Dockerfile for details)
        # =============================================================================
        # MODE 1 (Default): Download pre-built bundle (~1-2 min)
        #   BUNDLE_URL set to GitHub release URL
        #
        # MODE 2: Build indexes from scratch (~10-20 min)
        #   BUNDLE_URL: ""
        #   BUILD_INDEXES: "true"
        #   BUILD_MODEL: "FremyCompany/BioLORD-2023-M" (optional)
        #
        # MODE 3: External volume mount (no embedded data)
        #   BUNDLE_URL: ""
        #   BUILD_INDEXES: "false"
        # =============================================================================
        BUNDLE_URL: ${PHENTRIEVE_BUNDLE_URL:-https://github.com/berntpopp/phentrieve/releases/download/data-v2025-11-24-multivec/phentrieve-data-v2025-11-24-biolord-multivec.tar.gz}
        BUILD_INDEXES: ${PHENTRIEVE_BUILD_INDEXES:-false}
        BUILD_MODEL: ${PHENTRIEVE_BUILD_MODEL:-FremyCompany/BioLORD-2023-M}
      cache_from:
        - ghcr.io/berntpopp/phentrieve/api:latest

    # NOTE: Container starts as root to fix volume permissions, then drops to
    # non-root user (phentrieve:10001) via entrypoint script. This follows Docker
    # best practices for handling volume permissions with bind mounts.
    # See: https://www.docker.com/blog/understanding-the-docker-user-instruction/
    # user: "10001:10001"  # Handled by entrypoint script

    # SECURITY: Resource limits to prevent resource exhaustion attacks
    deploy:
      resources:
        limits:
          cpus: '4.0'      # Maximum 4 CPU cores
          memory: 8G       # Maximum 8GB RAM
        reservations:
          cpus: '1.0'      # Minimum 1 CPU core
          memory: 4G       # Minimum 4GB RAM

    # SECURITY: Security options
    security_opt:
      - no-new-privileges:true  # Prevent privilege escalation
      - seccomp:unconfined      # May need adjustment for ChromaDB operations

    # SECURITY: Drop all capabilities, then add back only what's needed
    cap_drop:
      - ALL
    # Add back CAP_CHOWN and CAP_FOWNER for entrypoint to fix volume permissions
    # These are dropped immediately after permission fixes via su-exec
    cap_add:
      - CHOWN
      - FOWNER
      - SETUID
      - SETGID

    # NOTE: read_only is disabled to allow entrypoint permission fixes
    # The application still runs as non-root after entrypoint completes
    # read_only: true

    # Writable tmpfs mounts for directories that need write access
    # Size limits prevent disk exhaustion attacks
    tmpfs:
      - /tmp:uid=10001,gid=10001,mode=1777,size=1G
      - /app/.cache:uid=10001,gid=10001,mode=0755,size=2G

    # Volume mounts with explicit read/write permissions
    # NOTE: Data directory needs read-write access for:
    #   - hpo_data.db: HPO SQLite database generated by 'phentrieve data prepare'
    #   - indexes/: ChromaDB vector indexes for semantic search
    #   - hp.json: Downloaded HPO ontology JSON file
    # Security is maintained via non-root user (UID 10001), read-only root filesystem,
    # and dropped capabilities.
    volumes:
      # Main data directory - read-write for HPO database generation and updates
      - ${PHENTRIEVE_HOST_DATA_DIR}:/phentrieve_data_mount:rw
      # Hugging Face cache for model downloads
      - ${PHENTRIEVE_HOST_HF_CACHE_DIR:-${PHENTRIEVE_HOST_DATA_DIR}/hf_cache}:/app/.cache/huggingface:rw

    # Environment variables
    # NOTE: PHENTRIEVE_DATA_DIR must be set explicitly to override legacy value
    # baked into GHCR image (which incorrectly used hpo_core_data subdirectory)
    environment:
      - PHENTRIEVE_DATA_ROOT_DIR=/phentrieve_data_mount
      - PHENTRIEVE_DATA_DIR=/phentrieve_data_mount
      - PHENTRIEVE_INDEX_DIR=/phentrieve_data_mount/indexes
      - PHENTRIEVE_RESULTS_DIR=/phentrieve_data_mount/results
      - LOG_LEVEL=${LOG_LEVEL_API:-INFO}
      - PYTHONPATH=/app
      - PYTHONDONTWRITEBYTECODE=1
      - PYTHONUNBUFFERED=1
      - HF_HOME=/app/.cache/huggingface
      - TRANSFORMERS_CACHE=/app/.cache/huggingface/hub
      # CORS: Add production frontend URLs (appends to defaults, comma-separated)
      # Example: CORS_EXTRA_ORIGINS=https://phentrieve.example.com,https://app.example.com
      - CORS_EXTRA_ORIGINS=${CORS_EXTRA_ORIGINS:-}
      # Environment indicator for version info endpoint (Issue #143)
      # Values: production, staging, development
      - ENV=${ENV:-production}
      # Data sync configuration (Issue #142)
      # PHENTRIEVE_DATA_SYNC: Enable/disable automatic data sync (default: true)
      # PHENTRIEVE_DATA_FORCE_SYNC: Force sync even if versions match (default: false)
      - PHENTRIEVE_DATA_SYNC=${PHENTRIEVE_DATA_SYNC:-true}
      - PHENTRIEVE_DATA_FORCE_SYNC=${PHENTRIEVE_DATA_FORCE_SYNC:-false}
      # MCP (Model Context Protocol) HTTP endpoint configuration
      # When enabled, mounts MCP server at /mcp on the same domain as the API
      # URL: https://your-domain.com/mcp (requires fastapi-mcp optional dependency)
      - ENABLE_MCP_HTTP=${ENABLE_MCP_HTTP:-true}

    # Enhanced health check with longer start period for model loading
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/api/v1/health || exit 1"]
      interval: 30s       # Check every 30 seconds
      timeout: 10s        # 10 second timeout
      retries: 5          # 5 retries before marking unhealthy
      start_period: 180s  # 3 minute grace period for initial startup

    # Structured logging with rotation to prevent disk exhaustion
    logging:
      driver: "json-file"
      options:
        max-size: "10m"   # Maximum 10MB per log file
        max-file: "3"     # Keep 3 rotated files (30MB total)
        labels: "service,env"

    restart: unless-stopped

    networks:
      - phentrieve_internal_net
      - npm_proxy_network

  phentrieve_frontend:
    image: ghcr.io/berntpopp/phentrieve/frontend:latest
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        BUILDKIT_INLINE_CACHE: 1
        VITE_API_URL: ${VITE_API_URL_PUBLIC}
      cache_from:
        - ghcr.io/berntpopp/phentrieve/frontend:latest

    # SECURITY: Run as non-root (nginx:nginx = 101:101)
    user: "101:101"

    # SECURITY: Resource limits for frontend (lower than API)
    deploy:
      resources:
        limits:
          cpus: '0.5'     # Maximum 0.5 CPU cores
          memory: 256M    # Maximum 256MB RAM
        reservations:
          cpus: '0.1'     # Minimum 0.1 CPU cores
          memory: 64M     # Minimum 64MB RAM

    # SECURITY: Security options
    security_opt:
      - no-new-privileges:true  # Prevent privilege escalation

    # SECURITY: Drop all capabilities (nginx doesn't need any)
    cap_drop:
      - ALL

    # SECURITY: Read-only root filesystem
    read_only: true

    # Writable tmpfs mounts for nginx runtime directories
    tmpfs:
      - /tmp:uid=101,gid=101,mode=1777,size=10M
      - /var/cache/nginx:uid=101,gid=101,mode=0755,size=50M
      - /var/run:uid=101,gid=101,mode=0755,size=10M

    # Enhanced health check using /health endpoint
    # Using wget instead of curl - wget is pre-installed in Alpine nginx image
    # Use 127.0.0.1 instead of localhost - Alpine images lack proper localhost DNS resolution
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://127.0.0.1:8080/health || exit 1"]
      interval: 30s       # Check every 30 seconds
      timeout: 5s         # 5 second timeout
      retries: 3          # 3 retries before marking unhealthy
      start_period: 10s   # 10 second grace period for startup

    # Structured logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "5m"    # Maximum 5MB per log file
        max-file: "2"     # Keep 2 rotated files (10MB total)
        labels: "service,env"

    # Wait for API to be healthy before starting frontend
    depends_on:
      phentrieve_api:
        condition: service_healthy

    restart: unless-stopped

    networks:
      - phentrieve_internal_net
      - npm_proxy_network

# Network configuration
networks:
  # Internal network for service-to-service communication
  phentrieve_internal_net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.25.0.0/16  # Explicit subnet for network isolation (changed from 172.20 to avoid conflicts)

  # External network for Nginx Proxy Manager (NPM)
  npm_proxy_network:
    external: true
    name: ${NPM_SHARED_NETWORK_NAME}
