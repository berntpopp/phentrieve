services:
  phentrieve_api:
    build:
      context: .
      dockerfile: api/Dockerfile # Assuming your Dockerfile is in the 'api' subdirectory
    env_file:
      - .env.docker 
    volumes:
      # Mount the single host data directory to the specified container path
      - ${PHENTRIEVE_HOST_DATA_DIR}:/phentrieve_data_mount 
      # For development: Mount code for live reload (comment out for production image)
      - ./phentrieve:/app/phentrieve
      - ./api:/app/api
    environment:
      - PHENTRIEVE_DATA_ROOT_DIR=/phentrieve_data_mount # Tells app where its data root is
      - LOG_LEVEL=${LOG_LEVEL_API:-INFO}
      - PYTHONPATH=/app # Ensures modules are found
    # No 'ports' section here; NPM handles external exposure.
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/api/v1/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 180s 
    restart: unless-stopped
    networks:
      - phentrieve_internal_net 
      - npm_proxy_network       # Connects to the shared network with NPM

  phentrieve_frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile 
    env_file:
      - .env.docker
    environment:
      # Pass the public API URL to Vite at build time if needed by the frontend app
      # If frontend/nginx.conf proxies /api/v1/ correctly, this might just be "/api/v1"
      VITE_API_URL: ${VITE_API_URL_PUBLIC} 
    # No 'ports' section here; NPM handles external exposure.
    depends_on:
      phentrieve_api:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - phentrieve_internal_net
      - npm_proxy_network

networks:
  phentrieve_internal_net: # Internal network for Phentrieve services
    driver: bridge
  npm_proxy_network: # External network shared with NPM
    external: true
    # This name MUST match the actual name of NPM's network (e.g., 'npm_default')
    # It will be read from the NPM_SHARED_NETWORK_NAME variable in .env.docker
    name: ${NPM_SHARED_NETWORK_NAME} 